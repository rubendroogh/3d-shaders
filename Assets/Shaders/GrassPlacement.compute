// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

struct SourceVertex {
    float3 positionOS;
    float2 uv;
};

StructuredBuffer<SourceVertex> _SourceVertices;
StructuredBuffer<int> _SourceIndices; // Indices is de meervoud van index

struct GeneratedVertex {
    float3 postionOS;
    float3 normalOS;
    float2 uv;
};

RWStructuredBuffer<GeneratedVertex> _GeneratedVertices;
RWStructuredBuffer<int> _GeneratedIndices;

int _NumSourceTriangles;
float _Height;
float4x4 _Transform;

SourceVertex Transform(SourceVertex v) {
    SourceVertex o;
    o.positionOS = mul(_Transform, float4(v.positionOS, 1)).xyz;
    o.uv = v.uv;
    return o;
}

float3 CalculateTriangleNormal(float3 a, float3 b, float3 c) {
    return normalize(cross(b - a, c - a));
}

GeneratedVertex MakeGeneratedVertex(SourceVertex source, float3 normal) {
    GeneratedVertex o;
    o.positionOS = source.positionOS;
    o.normalOS = normal;
    o.uv = source.uv;

    return o;
}

void AddTriangle(int startIndex, SourceVertex a, SourceVertex b, SourceVertex c) {
    float3 triangleNormal = CalculateTriangleNormal(a.positionOS, b.positionOS, c.positionOS);

    _GeneratedVertices[startIndex] = MakeGeneratedVertex(a, triangleNormal);
    _GeneratedVertices[startIndex + 1] = MakeGeneratedVertex(b, triangleNormal);
    _GeneratedVertices[startIndex + 2] = MakeGeneratedVertex(c, triangleNormal);

    _GeneratedIndices[startIndex] = startIndex;
    _GeneratedIndices[startIndex + 1] = startIndex + 1;
    _GeneratedIndices[startIndex + 2] = startIndex + 2;
}

[numthreads(128,1,1)]
void Main (uint3 id : SV_DispatchThreadID)
{
    // Make sure we return when we're on a thread more than amount of triangles
    if ((int)id.x >= _NumSourceTriangles) {
        return;
    }

    int triStart = id.x * 3;
    SourceVertex a = Transform(_SourceVertices[_SourceIndices[triStart]]);
    SourceVertex b = Transform(_SourceVertices[_SourceIndices[triStart + 1]]);
    SourceVertex c = Transform(_SourceVertices[_SourceIndices[triStart + 2]]);

    float3 triNormal = CalculateTriangleNormal(a.positionOS, b.positionOS, c.positionOS);
    SourceVertex center;
    center.positionOS = (a.positionOS + b.positionOS + c.positionOS) / 3 + triNormal * _Height;
    center.uv = (a.uv + b.uv + c.uv) / 3;

    int generatedStart = id.x * 3 * 3;

    AddTriangle(generatedStart, a, b, center);
    AddTriangle(generatedStart + 3, b, c, center);
    AddTriangle(generatedStart + 6, c, a, center);
}
